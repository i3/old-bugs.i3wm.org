*** ./i3-config-wizard/main.c.orig	2012-01-27 20:24:09.000000000 +0100
--- ./i3-config-wizard/main.c	2012-02-08 23:37:50.000000000 +0100
***************
*** 24,29 ****
--- 24,33 ----
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <glob.h>
+ #if defined(__FreeBSD__)
+ #include <sys/param.h>
+ #endif
+ 
  
  #include <xcb/xcb.h>
  #include <xcb/xcb_aux.h>
***************
*** 50,55 ****
--- 54,63 ----
  #include "xcb.h"
  #include "libi3.h"
  
+ #if defined(__APPLE__) || (defined(__FreeBSD__) && __FreeBSD_version < 800000)
+ #define USE_FGETLN
+ #endif
+ 
  enum { STEP_WELCOME, STEP_GENERATE } current_step = STEP_WELCOME;
  enum { MOD_Mod1, MOD_Mod4 } modifier = MOD_Mod4;
  
***************
*** 280,292 ****
      FILE *ks_config = fopen(config_path, "w");
      if (ks_config == NULL)
          err(1, "Could not open output config file \"%s\"", config_path);
  
      char *line = NULL;
      size_t len = 0;
! #if !defined(__APPLE__)
      ssize_t read;
  #endif
-     bool head_of_file = true;
  
      /* write a header about auto-generation to the output file */
      fputs("# This file has been auto-generated by i3-config-wizard(1).\n", ks_config);
--- 288,301 ----
      FILE *ks_config = fopen(config_path, "w");
      if (ks_config == NULL)
          err(1, "Could not open output config file \"%s\"", config_path);
+     free(config_path);
  
      char *line = NULL;
      size_t len = 0;
!     bool head_of_file = true;
! #ifndef USE_FGETLN
      ssize_t read;
  #endif
  
      /* write a header about auto-generation to the output file */
      fputs("# This file has been auto-generated by i3-config-wizard(1).\n", ks_config);
***************
*** 296,305 ****
      fputs("# this file and re-run i3-config-wizard(1).\n", ks_config);
      fputs("#\n", ks_config);
  
! #if defined(__APPLE__)
      while ((line = fgetln(kc_config, &len)) != NULL) {
  #else
!     while ((read = getline(&line, &len, kc_config)) != -1) {
  #endif
          /* skip the warning block at the beginning of the input file */
          if (head_of_file &&
--- 305,317 ----
      fputs("# this file and re-run i3-config-wizard(1).\n", ks_config);
      fputs("#\n", ks_config);
  
! #ifdef USE_FGETLN
!     char *buf = NULL;
      while ((line = fgetln(kc_config, &len)) != NULL) {
  #else
!       size_t linecap = 0;
!       while ((read = getline(&line, &linecap, kc_config)) != -1) {
! 	len = strlen(line);
  #endif
          /* skip the warning block at the beginning of the input file */
          if (head_of_file &&
***************
*** 308,342 ****
  
          head_of_file = false;
  
          /* Skip leading whitespace */
          char *walk = line;
!         while (isspace(*walk) && walk < (line + len))
              walk++;
  
-         /* Set the modifier the user chose */
          if (strncmp(walk, "set $mod ", strlen("set $mod ")) == 0) {
              if (modifier == MOD_Mod1)
                  fputs("set $mod Mod1\n", ks_config);
!             else fputs("set $mod Mod4\n", ks_config);
!             continue;
!         }
! 
!         /* Check for 'bindcode'. If it’s not a bindcode line, we
!          * just copy it to the output file */
!         if (strncmp(walk, "bindcode", strlen("bindcode")) != 0) {
!             fputs(line, ks_config);
!             continue;
!         }
!         char *result = rewrite_binding(walk);
!         fputs(result, ks_config);
!         free(result);
      }
  
      /* sync to do our best in order to have the file really stored on disk */
      fflush(ks_config);
      fsync(fileno(ks_config));
  
      free(line);
      fclose(kc_config);
      fclose(ks_config);
  
--- 320,386 ----
  
          head_of_file = false;
  
+ #ifdef USE_FGETLN
+ 	/* Proper handling of fgetln */
+ 	if (line[len-1] == '\n') {
+ 	  line[len-1] = '\0';
+ 	  --len;
+ 	} else {
+ 	  /* EOF without EOL */
+ 	  buf = malloc(len + 1);
+ 	  if (buf == NULL)
+ 	    err(EXIT_FAILURE, "malloc() failed\n");
+ 	  memcpy(buf, line, len);
+ 	  buf[len] = '\0';
+ 	  line = buf;
+ 	}
+ #else
+ 	if (len > 0 && line[len-1] == '\n') {
+ 	  line[len-1] = '\0';
+ 	  --len;
+ 	}
+ 
+ 	if (strchr(line, '\n') != NULL)
+ 	  fprintf(stderr, "We still have \\n's !\n");
+ #endif
+ 
          /* Skip leading whitespace */
          char *walk = line;
!         while (isspace(*walk) && walk < (line + len)) {
!             /* Pre-output the skipped whitespaces to keep proper indentation */
!             fputc(*walk, ks_config);
              walk++;
+         }
  
          if (strncmp(walk, "set $mod ", strlen("set $mod ")) == 0) {
+             /* Set the modifier the user chose */
              if (modifier == MOD_Mod1)
                  fputs("set $mod Mod1\n", ks_config);
!             else 
! 	        fputs("set $mod Mod4\n", ks_config);
!         } else if (strncmp(walk, "bindcode", strlen("bindcode")) == 0) {
! 	  /* Check for 'bindcode' */
!             char *result = rewrite_binding(walk);
!             fputs(result, ks_config);
!             free(result);
!         } else {
! 	  /* If it’s not a bindcode line, we
! 	   * just copy it to the output file */
! 	  fputs(walk, ks_config);
! 	  fputc('\n', ks_config);
! 	}
      }
  
      /* sync to do our best in order to have the file really stored on disk */
      fflush(ks_config);
      fsync(fileno(ks_config));
  
+ #ifdef USE_FGETLN
+     free(buf);
+ #else
      free(line);
+ #endif
+ 
      fclose(kc_config);
      fclose(ks_config);
  
